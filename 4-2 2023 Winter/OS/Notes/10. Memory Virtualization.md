# Early Memory Management
- Rewind to the days of “second-generation” computers
	- 8086 type beat
	- Programs use physical addresses directly
	- OS loads a job, runs it, unloads it
	- Poor memory utilization
- Multiprogramming changes all of this
	- ![[Pasted image 20230221170242.png|125]]
	- Multiple processes in memory at once
	- When a process needs more memory, we use paging
		- Otherwise, we would need to move a process worth of memory around to allocate and empty space of a process is wasted
## Issues in Sharing Physical Memory
- Protection
	- A bug in one process can corrupt memory in another
	- Must somehow prevent process A from trashing B’s memory
	- Also prevent A from even observing B’s memory
	- OS is isolated
- Transparency
	- A process shouldn’t require particular physical memory bits
	- Yet processes often require large amounts of contiguous memory (for stack, large data structures, etc.)
- Resource Exhaustion
	- Programmers typically assume machine has “enough” memory
	- Sum of sizes of all processes often greater than physical memory
# Memory Virtualization
- ![[Pasted image 20230221172459.png|300]]
- Give each program its own virtual address space (sandbox andies)
	- At runtime, Memory-Management Unit relocates each load/store
	- Application doesn’t see physical memory addresses
- Enforce protection
	- Prevent one app from messing with another’s memory
		- Segmentation Fault is when a process goes beyond its space
- All addresses GENERATED by the CPU is Virtual
	- The MMU is on the CPU, which then CONVERTS the Virtual Address to Physical
# Virtual Addressing
- Every address is virtual (aka Virtual Address Space, Address Space, AS)
	- - ![[Pasted image 20230221172634.png|120]]
		- From the the top
			- Program itself
			- Static Data (const)
			- Heap, which grows downwards
		- Stack grows negatively from bottom
	- OS translates virtual to physical addresses
## Example: va.c
- ![[Pasted image 20230221172706.png|350]]
	- Will print out Virtual Address of main(), a random bit malloc on heap, and an int on the stack.
## In Relation to Physical Address Space
- ![[Pasted image 20230223153640.png|250]]
# Definitions Summary
- ![[Pasted image 20230223155420.png|300]]
# Base and Bounds
- It is also called: Dynamic relocation
- Two registers base & bounds: on the CPU
	- The **start (base)** & **end (base + bound)** of virtual address space in the physical address space
- On each load/store/jump:
	- **Physical address = virtual address + base**
	- **Check valid if (0 ≤ virtual address < bound), else trap to kernel**
		- base ≤ address < base + bound
- Simplest, oldest implementation
	- Modern computer not using, maybe only simple one off computers nowadays
- When we move a process in memory, we have to just change the base register.
- When we do context switch, OS reloads the base and bounds register
## Exercise
- 4 KB (4096 bytes) address space, loaded at 16 KB physical location
	- Virtual Address Space: min = 0 & max = 4095
	- Physical Address Space: base = 16KB & bounds = 4KB (because the ending address = base + bounds = 20KB)
	- ![[Pasted image 20230223160555.png|250]]
## OS Support for Memory Virtualization
- When process starts running
	- Allocate address space in physical memory
- When a process is terminated
	- Reclaiming memory for use
- When context switch occurs
	- Saving and storing the base-bounds pair
- Exception handlers
	- Function pointers set at OS boot time
### OS: When Process Starts Running
- OS searches for free space for new process
	- Free list: a data structure (linked list) that tracks available memory slots
		- Limitation is that a large program might need O(n) to find possible spacing, and also reordering
	- ![[Pasted image 20230223161128.png|250]]
### OS: When Process is Terminated
- OS places memory back on the free list
	- ![[Pasted image 20230223161313.png|350]]
### OS: When Context Switch Occurs
- OS must save base and bounds registers
	- Saved to the Process Control Block PCB (task_struct in Linux)
	- ![[Pasted image 20230223161654.png|350]]
		- (btw, base and bounds is used in textbook as address space, which is not what we are using)
## Dynamic Relocation
- OS can move process data when not running
- ![[Pasted image 20230223161859.png|300]]
	- When process runs new base & bound registers are restored to CPU
	- Process doesn’t know it was even moved!
## Base and Bounds Trade-offs
- Advantage
	- Computationally cheap. Add and compare.
	- Cheap in terms of HW, needs base and bound
- Disadvantage
	- Growing a process is expensive or impossible
		- Must move whole processes around
	- Lots of unused memory because you can't break it
	- No way to share code or data
		- Threads can't share data
- We can solve this issue by splitting & tracking segments
	- i.e. code, stack, heap
# Segmentation (Segmented Base and Bound)
- Address space has 3 segments (code, stack, heap)
	- Each contiguous
	- Each logically separated
-  The mapping can be placed separately
	-  ![[Pasted image 20230223163418.png|100]]
	- Each segment can be shared/protected to/from differently
	- Each has a base & bounds, requiring 6 registers
-  **PA = VA - VA_base + PA_base**
## Segments in Memory
- Consider these 3 segments as an example:
	- ![[Pasted image 20230223163418.png|100]]![[Pasted image 20230223163806.png|150]]
		- Each has a size of 2K (meaning OS can specify size)
		- The stack's base is the maximum address
### Exercise: 
#### Address Translation - Code Segment
- **PA** = VA - VA_base + PA_base = VA - 0 + PA_base = **VA + PA_base**
- Code segment - physically starts at 32KB (base) & Starting  at “0” in virtual address space
- ![[Pasted image 20230223170244.png|300]]
	- To find PA for Code Segment @ VA 100B, then PA = 100B - 0B + 32KB
#### Address Translation - Heap
- **PA = VA - VA_base + PA_base**
- Heap starts at VA 4096B = 4KB
- ![[Pasted image 20230223170644.png|250]]
	- Heap @ VA 4200B means PA = 4200B - 4KB + 34KB
#### Segmentation Fault - Heap
- Heap starts at VA 4096B = 4KB
- ![[Pasted image 20230223170644.png|250]]
	- Getting the data at VA 7KB is a segmentation fault
#### Stack Segment
- Stack grows backwards
- **PA = PA_base - VA_base + VA** 
- **PA_base = PA + VA_base - VA**
- ![[Pasted image 20230223171729.png|350]]
	- So to get PA of VA @ 15KB
		- PA = 28K - (16KB - 1) + 15KB
## Segmentation Trade-offs
- Advantage
	- Multiple segments per process, able to share memory allowing for threads
	- The whole process doesn't have to be contiguous
- Disadvantage
	- Fragmentation, the space between segments are unused
	- Needs a better MMU to translate with all these offsets
# Memory Fragmentation
- ![[Pasted image 20230223173256.png|100]]
	- These unused segments adds up
	- We can rearrange and **compact** the segments, but it's lots of work the bigger the segments, potentially needing to write on disk as buffer